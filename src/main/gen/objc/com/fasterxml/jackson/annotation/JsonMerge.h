//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Salton/Documents/Projects/jackson-annotations/src/main/java/com/fasterxml/jackson/annotation/JsonMerge.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonMerge")
#ifdef RESTRICT_ComFasterxmlJacksonAnnotationJsonMerge
#define INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonMerge 0
#else
#define INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonMerge 1
#endif
#undef RESTRICT_ComFasterxmlJacksonAnnotationJsonMerge

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComFasterxmlJacksonAnnotationJsonMerge_) && (INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonMerge || defined(INCLUDE_ComFasterxmlJacksonAnnotationJsonMerge))
#define ComFasterxmlJacksonAnnotationJsonMerge_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

@class ComFasterxmlJacksonAnnotationOptBoolean;
@class IOSClass;

/*!
 @brief Annotation to specify whether annotated property value should use "merging" approach,
  in which current value is first accessed (with a getter or field) and then modified
  with incoming data, or not: if not, assignment happens without considering current state.
 <p>
  Merging is only option if there is a way to introspect current state:
  if there is accessor (getter, field) to use.
  Merging can not be enabled if no accessor exists
  or if assignment occurs using a Creator setter (constructor
  or factory method), since there is no instance with state to introspect.
  Merging also only has actual effect for structured types where there is an
  obvious way to update a state (for example, POJOs have default values for properties,
  and <code>java.util.Collection</code>s and <code>java.util.Map</code>s may have existing
  elements; whereas scalar types do not such state: an <code>int</code> has a value,
  but no obvious and non-ambiguous way to merge state.
 <p>
  Merging is applied by using a deserialization method that accepts existing state
  as an argument: it is then up to <code>JsonDeserializer</code> implementation
  to use that base state in a way that makes sense without further configuration.
  For structured types this is usually obvious; and for scalar types not -- if
  no obvious method exists, merging is not allowed; deserializer may choose to
  either quietly ignore it, or throw an exception.
 <p>
  Note that use of merging usually adds some processing overhead since it adds
  an extra step of accessing the current state before assignment.
 <p>
  Note also that "root values" (values directly deserialized and not reached
  via POJO properties) can not use this annotation; instead, <code>ObjectMapper</code>
  and <code>Object</code> have "updating reader" operations.
 <p>
  Default value is <code>OptBoolean.TRUE</code>, that is, merging <b>is enabled</b>.
 @since 2.9
 */
@protocol ComFasterxmlJacksonAnnotationJsonMerge < JavaLangAnnotationAnnotation >

@property (readonly) ComFasterxmlJacksonAnnotationOptBoolean *value;

- (jboolean)isEqual:(id)obj;

- (NSUInteger)hash;

@end

@interface ComFasterxmlJacksonAnnotationJsonMerge : NSObject < ComFasterxmlJacksonAnnotationJsonMerge > {
 @public
  ComFasterxmlJacksonAnnotationOptBoolean *value_;
}

@end

J2OBJC_EMPTY_STATIC_INIT(ComFasterxmlJacksonAnnotationJsonMerge)

FOUNDATION_EXPORT id<ComFasterxmlJacksonAnnotationJsonMerge> create_ComFasterxmlJacksonAnnotationJsonMerge(ComFasterxmlJacksonAnnotationOptBoolean *value);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonAnnotationJsonMerge)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonMerge")
