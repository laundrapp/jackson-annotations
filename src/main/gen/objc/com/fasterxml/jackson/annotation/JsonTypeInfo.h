//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Salton/Documents/Projects/jackson-annotations/src/main/java/com/fasterxml/jackson/annotation/JsonTypeInfo.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonTypeInfo")
#ifdef RESTRICT_ComFasterxmlJacksonAnnotationJsonTypeInfo
#define INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonTypeInfo 0
#else
#define INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonTypeInfo 1
#endif
#undef RESTRICT_ComFasterxmlJacksonAnnotationJsonTypeInfo

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComFasterxmlJacksonAnnotationJsonTypeInfo_) && (INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonTypeInfo || defined(INCLUDE_ComFasterxmlJacksonAnnotationJsonTypeInfo))
#define ComFasterxmlJacksonAnnotationJsonTypeInfo_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

@class ComFasterxmlJacksonAnnotationJsonTypeInfo_As;
@class ComFasterxmlJacksonAnnotationJsonTypeInfo_Id;
@class IOSClass;

/*!
 @brief Annotation used for configuring details of if and how type information is
  used with JSON serialization and deserialization, to preserve information
  about actual class of Object instances.This is necessarily for polymorphic
  types, and may also be needed to link abstract declared types and matching
  concrete implementation.
 <p>
  Some examples of typical annotations:
 @code

   // Include Java class name ("com.myempl.ImplClass") as JSON property "class"  
  &#064;JsonTypeInfo(use=Id.CLASS, include=As.PROPERTY, property="class")
   
   // Include logical type name (defined in impl classes) as wrapper; 2 annotations  
  &#064;JsonTypeInfo(use=Id.NAME, include=As.WRAPPER_OBJECT)
    &#064;JsonSubTypes({com.myemp.Impl1.class, com.myempl.Impl2.class})
 
@endcode
  Alternatively you can also define fully customized type handling by using 
 <code>&#064;JsonTypeResolver</code> annotation (from databind package).
 <p>
  This annotation can be used both for types (classes) and properties.
  If both exist, annotation on property has precedence, as it is
  considered more specific.
 <p>
  When used for properties (fields, methods), this annotation applies
  to <b>values</b>: so when applied to structure types
  (like <code>java.util.Collection</code>, <code>java.util.Map</code>, arrays),
  will apply to contained values, not the container;
  for non-structured types there is no difference.
  This is identical to how JAXB handles type information
  annotations; and is chosen since it is the dominant use case.
  There is no per-property way to force type information to be included
  for type of container (structured type); for container types one has
  to use annotation for type declaration.
 <p>
  Note on visibility of type identifier: by default, deserialization
  (use during reading of JSON) of type identifier
  is completely handled by Jackson, and is <b>not passed to</b>
  deserializers. However, if so desired,
  it is possible to define property <code>visible = true</code>
  in which case property will be passed as-is to deserializers
  (and set via setter or field) on deserialization.
 <p>
  On serialization side, Jackson will generate type id by itself,
  except if there is a property with name that matches 
 <code>property()</code>, in which case value of that property is
  used instead.
 <p>
  NOTE: use of type id of "class name" with very general base type
  (such as <code>java.lang.Object</code> or <code>java.io.Serializable</code>)
  can potentially open up security holes if deserializing content
  generated by untrusted sources. If content can not be trusted,
  it is necessary to either use "type name" as type id, or to
  limit possible types using other means.
 */
@protocol ComFasterxmlJacksonAnnotationJsonTypeInfo < JavaLangAnnotationAnnotation >

@property (readonly) ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *use;
@property (readonly) ComFasterxmlJacksonAnnotationJsonTypeInfo_As *include;
@property (readonly) NSString *property;
@property (readonly) IOSClass *defaultImpl;
@property (readonly) jboolean visible;

- (jboolean)isEqual:(id)obj;

- (NSUInteger)hash;

@end

@interface ComFasterxmlJacksonAnnotationJsonTypeInfo : NSObject < ComFasterxmlJacksonAnnotationJsonTypeInfo > {
 @public
  ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *use_;
  ComFasterxmlJacksonAnnotationJsonTypeInfo_As *include_;
  NSString *property_;
  IOSClass *defaultImpl_;
  jboolean visible_;
}

@end

J2OBJC_EMPTY_STATIC_INIT(ComFasterxmlJacksonAnnotationJsonTypeInfo)

FOUNDATION_EXPORT id<ComFasterxmlJacksonAnnotationJsonTypeInfo> create_ComFasterxmlJacksonAnnotationJsonTypeInfo(IOSClass *defaultImpl, ComFasterxmlJacksonAnnotationJsonTypeInfo_As *include, NSString *property, ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *use, jboolean visible);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonAnnotationJsonTypeInfo)

#endif

#if !defined (ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_) && (INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonTypeInfo || defined(INCLUDE_ComFasterxmlJacksonAnnotationJsonTypeInfo_Id))
#define ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_Enum) {
  ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_Enum_NONE = 0,
  ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_Enum_CLASS = 1,
  ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_Enum_MINIMAL_CLASS = 2,
  ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_Enum_NAME = 3,
  ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_Enum_CUSTOM = 4,
};

/*!
 @brief Definition of different type identifiers that can be included in JSON
  during serialization, and used for deserialization.
 */
@interface ComFasterxmlJacksonAnnotationJsonTypeInfo_Id : JavaLangEnum

#pragma mark Public

- (NSString *)getDefaultPropertyName;

+ (ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

@end

J2OBJC_STATIC_INIT(ComFasterxmlJacksonAnnotationJsonTypeInfo_Id)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_values_[];

/*!
 @brief This means that no explicit type metadata is included, and typing is
  purely done using contextual information possibly augmented with other
  annotations.
 */
inline ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_get_NONE(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonAnnotationJsonTypeInfo_Id, NONE)

/*!
 @brief Means that fully-qualified Java class name is used as the type identifier.
 */
inline ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_get_CLASS(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonAnnotationJsonTypeInfo_Id, CLASS)

/*!
 @brief Means that Java class name with minimal path is used as the type identifier.
 Minimal means that only the class name, and that part of preceding Java
  package name is included that is needed to construct fully-qualified name
  given fully-qualified name of the declared supertype; additionally a single
  leading dot ('.') must be used to indicate that partial class name is used.
  For example, for supertype "com.foobar.Base", and concrete type
  "com.foo.Impl", only ".Impl" would be included; and for "com.foo.impl.Impl2"
  only ".impl.Impl2" would be included.
 <br>
  <b>NOTE</b>: leading dot ('.') MUST be used to denote partial (minimal) name;
  if it is missing, value is assumed to be fully-qualified name. Fully-qualified
  name is used in cases where subtypes are not in same package (or sub-package
  thereof) as base class.
 <p>
  If all related classes are in the same Java package, this option can reduce
  amount of type information overhead, especially for small types.
  However, please note that using this alternative is inherently risky since it
  assumes that the
  supertype can be reliably detected. Given that it is based on declared type
  (since ultimate supertype, <code>java.lang.Object</code> would not be very
  useful reference point), this may not always work as expected.
 */
inline ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_get_MINIMAL_CLASS(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonAnnotationJsonTypeInfo_Id, MINIMAL_CLASS)

/*!
 @brief Means that logical type name is used as type information; name will then need
  to be separately resolved to actual concrete type (Class).
 */
inline ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_get_NAME(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonAnnotationJsonTypeInfo_Id, NAME)

/*!
 @brief Means that typing mechanism uses customized handling, with possibly
  custom configuration.This means that semantics of other properties is
  not defined by Jackson package, but by the custom implementation.
 */
inline ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_get_CUSTOM(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonAnnotationJsonTypeInfo_Id, CUSTOM)

FOUNDATION_EXPORT IOSObjectArray *ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_values(void);

FOUNDATION_EXPORT ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT ComFasterxmlJacksonAnnotationJsonTypeInfo_Id *ComFasterxmlJacksonAnnotationJsonTypeInfo_Id_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonAnnotationJsonTypeInfo_Id)

#endif

#if !defined (ComFasterxmlJacksonAnnotationJsonTypeInfo_As_) && (INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonTypeInfo || defined(INCLUDE_ComFasterxmlJacksonAnnotationJsonTypeInfo_As))
#define ComFasterxmlJacksonAnnotationJsonTypeInfo_As_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, ComFasterxmlJacksonAnnotationJsonTypeInfo_As_Enum) {
  ComFasterxmlJacksonAnnotationJsonTypeInfo_As_Enum_PROPERTY = 0,
  ComFasterxmlJacksonAnnotationJsonTypeInfo_As_Enum_WRAPPER_OBJECT = 1,
  ComFasterxmlJacksonAnnotationJsonTypeInfo_As_Enum_WRAPPER_ARRAY = 2,
  ComFasterxmlJacksonAnnotationJsonTypeInfo_As_Enum_EXTERNAL_PROPERTY = 3,
  ComFasterxmlJacksonAnnotationJsonTypeInfo_As_Enum_EXISTING_PROPERTY = 4,
};

/*!
 @brief Definition of standard type inclusion mechanisms for type metadata.
 Used for standard metadata types, except for <code>Id.NONE</code>.
  May or may not be used for custom types (<code>Id.CUSTOM</code>).
 */
@interface ComFasterxmlJacksonAnnotationJsonTypeInfo_As : JavaLangEnum

#pragma mark Public

+ (ComFasterxmlJacksonAnnotationJsonTypeInfo_As *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

@end

J2OBJC_STATIC_INIT(ComFasterxmlJacksonAnnotationJsonTypeInfo_As)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT ComFasterxmlJacksonAnnotationJsonTypeInfo_As *ComFasterxmlJacksonAnnotationJsonTypeInfo_As_values_[];

/*!
 @brief Inclusion mechanism that uses a single configurable property, included
  along with actual data (POJO properties) as a separate meta-property.
 <p>
  Default choice for inclusion.
 */
inline ComFasterxmlJacksonAnnotationJsonTypeInfo_As *ComFasterxmlJacksonAnnotationJsonTypeInfo_As_get_PROPERTY(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonAnnotationJsonTypeInfo_As, PROPERTY)

/*!
 @brief Inclusion mechanism that wraps typed JSON value (POJO
  serialized as JSON) in
  a JSON Object that has a single entry,
  where field name is serialized type identifier,
  and value is the actual JSON value.
 <p>
  Note: can only be used if type information can be serialized as
  String. This is true for standard type metadata types, but not
  necessarily for custom types.
 */
inline ComFasterxmlJacksonAnnotationJsonTypeInfo_As *ComFasterxmlJacksonAnnotationJsonTypeInfo_As_get_WRAPPER_OBJECT(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonAnnotationJsonTypeInfo_As, WRAPPER_OBJECT)

/*!
 @brief Inclusion mechanism that wraps typed JSON value (POJO
  serialized as JSON) in
  a 2-element JSON array: first element is the serialized
  type identifier, and second element the serialized POJO
  as JSON Object.
 */
inline ComFasterxmlJacksonAnnotationJsonTypeInfo_As *ComFasterxmlJacksonAnnotationJsonTypeInfo_As_get_WRAPPER_ARRAY(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonAnnotationJsonTypeInfo_As, WRAPPER_ARRAY)

/*!
 @brief Inclusion mechanism similar to <code>PROPERTY</code>, except that
  property is included one-level higher in hierarchy, i.e.as sibling
  property at same level as JSON Object to type.
 Note that this choice <b>can only be used for properties</b>, not
  for types (classes). Trying to use it for classes will result in
  inclusion strategy of basic <code>PROPERTY</code> instead.
 */
inline ComFasterxmlJacksonAnnotationJsonTypeInfo_As *ComFasterxmlJacksonAnnotationJsonTypeInfo_As_get_EXTERNAL_PROPERTY(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonAnnotationJsonTypeInfo_As, EXTERNAL_PROPERTY)

/*!
 @brief Inclusion mechanism similar to <code>PROPERTY</code> with respect
  to deserialization; but one that is produced by a "regular" accessible
  property during serialization.This means that <code>TypeSerializer</code>
  will do nothing, and expects a property with defined name to be output
  using some other mechanism (like default POJO property serialization, or
  custom serializer).
 <p>
  Note that this behavior is quite similar to that of using <code>JsonTypeId</code>
  annotation;
  except that here <code>TypeSerializer</code> is basically suppressed;
  whereas with <code>JsonTypeId</code>, output of regular property is suppressed.
  This mostly matters with respect to output order; this choice is the only
  way to ensure specific placement of type id during serialization.
 @since 2.3.0 but databind <b>only since 2.5.0</b>.
 */
inline ComFasterxmlJacksonAnnotationJsonTypeInfo_As *ComFasterxmlJacksonAnnotationJsonTypeInfo_As_get_EXISTING_PROPERTY(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonAnnotationJsonTypeInfo_As, EXISTING_PROPERTY)

FOUNDATION_EXPORT IOSObjectArray *ComFasterxmlJacksonAnnotationJsonTypeInfo_As_values(void);

FOUNDATION_EXPORT ComFasterxmlJacksonAnnotationJsonTypeInfo_As *ComFasterxmlJacksonAnnotationJsonTypeInfo_As_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT ComFasterxmlJacksonAnnotationJsonTypeInfo_As *ComFasterxmlJacksonAnnotationJsonTypeInfo_As_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonAnnotationJsonTypeInfo_As)

#endif

#if !defined (ComFasterxmlJacksonAnnotationJsonTypeInfo_None_) && (INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonTypeInfo || defined(INCLUDE_ComFasterxmlJacksonAnnotationJsonTypeInfo_None))
#define ComFasterxmlJacksonAnnotationJsonTypeInfo_None_

/*!
 @brief This marker class that is only to be used with <code>defaultImpl</code>
  annotation property, to indicate that there is no default implementation
  specified.
 */
@interface ComFasterxmlJacksonAnnotationJsonTypeInfo_None : NSObject

#pragma mark Public

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(ComFasterxmlJacksonAnnotationJsonTypeInfo_None)

FOUNDATION_EXPORT void ComFasterxmlJacksonAnnotationJsonTypeInfo_None_init(ComFasterxmlJacksonAnnotationJsonTypeInfo_None *self);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonAnnotationJsonTypeInfo_None)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_ComFasterxmlJacksonAnnotationJsonTypeInfo")
